<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>朝花夕拾</title>
  
  <subtitle>人有悲欢离合，月有阴晴圆缺，此事古难全，但愿人长久，千里共婵娟</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wusz.com/"/>
  <updated>2018-04-27T15:57:26.605Z</updated>
  <id>http://wusz.com/</id>
  
  <author>
    <name>Chenyk</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Windows 用户、认证和对象安全</title>
    <link href="http://wusz.com/2018/04/27/Windows%20%E7%94%A8%E6%88%B7%E3%80%81%E8%AE%A4%E8%AF%81%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%AE%89%E5%85%A8/"/>
    <id>http://wusz.com/2018/04/27/Windows 用户、认证和对象安全/</id>
    <published>2018-04-27T12:30:33.650Z</published>
    <updated>2018-04-27T15:57:26.605Z</updated>
    
    <content type="html"><![CDATA[<h3>一、概述</h3><br>&emsp;&emsp;Windows系统具有很完善的安全和认证机制，称做访问控制机制。程序的执行主体（线程）在访问对象（文件，事件）时，系统会根据线程的“权限”和线程需要访问的对象所具有的“安全描述符”中的访问控制列表是否匹配来进行认证，决定一个线程是否可以操作一个对象。<br><a id="more"></a><br><h3>二、定义</h3><br>&emsp;&emsp;关于权限、访问控制列表、安全描述符等在安全认证中所依赖的数据结构、并重点讲解安全认证的过程<br>&emsp;&emsp;A需要访问（Access）B，A就是访问的主体，B就是访问的客体。A的“访问令牌”和B的安全描述符共同决定了A是否可以访问B<br>&emsp;&emsp;访问的主体是进程。在系统中，线程才是程序执行的流程，因此只有线程才能操作对象。每个线程都是属于一个进程的，线程并没有属于自己的权限，而是来源于线程所属的进程。一个进程中的所有线程都具有同样的权限，可以把进程看做访问的主体，一个线程能访问哪些对象，都能进行哪些操作，是由线程权限决定的。访问的客体是安全对象，所有被访问的对象都具有安全描述符，包括了文件、注册表、事件（Event），互斥（Mutex）、管道等<br><br><br><h3>三、访问令牌、权限和用户标识</h3><h4>3.1、进程的系统操作权限</h4><br>&emsp;&emsp;进程的权限特指进程是否能够进行各种系统操作，例如是否可以关闭系统、是否能够修改系统时间、是否能够加载设备驱动、权限是一个列表，没种权限是列表中的一项。<strong>权限列表存在与进程的访问令牌中</strong>。<br>&emsp;&emsp;权限有很多种，每一种表示了一个特定的操作是否能够进行，如果进程的访问令牌中的权限列表中有这个权限，则表示进程可以进行这种操作，比如SE_LOAD_DRIVER_NAME表示进程可以加载驱动。<br>#define SE_CREATE_TOKEN_NAME                  “SeCreateTokenPrivilege”<br><br>#define SE_ASSIGNPRIMARYTOKEN_NAME            “SeAssignPrimaryTokenPrivilege”<br><br>#define SE_LOCK_MEMORY_NAME                   “SeLockMemoryPrivilege”<br><br>#define SE_INCREASE_QUOTA_NAME                “SeIncreaseQuotaPrivilege”<br><br>#define SE_UNSOLICITED_INPUT_NAME             “SeUnsolictedInputPrivilege”<br>更多权限请点击<a href="https://msdn.microsoft.com/zh-cn/library/windows/desktop/bb530716%28v=vs.85%29.aspx" target="_blank" rel="noopener">Privilege Content</a><br><br><br><br><h4>3.2、安全对象</h4><br>&emsp;&emsp;Windows系统几乎所有的对象都有安全属性、包括文件、文件夹、注册表、线程同步对象、进程间通信对象、网络共享等，进程和线程也可以使其他进程的操作对象，所以进程和线程也是安全对象。在创建对象时都可以指定对象的安全属性，比如CreateFile，CreatePipe,CreateProcess,RegCreateKeyEx和RegSaveKeyEx等，SECURITY_ATTRIBUTES结构用于指定对象的安全属性。GetNamedSecurityInfo,GetSecurityInfo,SetSecurityInfo,SetKernelObjectSecurity,SetNameSecurityInfo等API函数可以获取和设置对象的安全属性。对象的安全属性是以安全描述符（Security Descriptor）的形式存在的，安全描述符中包括了访问控制列表。<br><br><br><h4>3.3、访问控制列表（ACL）</h4><br>&mesp;&emsp;每个安全对象都有访问控制列表。访问控制列表有两种， 一种是选择访问控制列表（discreionary access control list,DACL）,另一种是系统访问控制列表（system access control list，SACL）.DACL决定了用户或用户组是否能访问这个对象，SACL控制了尝试访问安全对象的检测信息的继承关系<br>&emsp;&emsp;DACL是访问控制的关键，如图1，DACL中包括一个访问控制入口（AccessControl Entries,ACE）列表。ACE表明了用户（通过用户SID或用户组）是否能够进行操作以及能进行那种操作。在进行访问控制检测时，会依次检测DACL中的ACE，知道被允许或被拒绝<br><br><img src="http://img.blog.csdn.net/20171021084134214?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbnlvbmtlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图1"><br><br><img src="http://img.blog.csdn.net/20171021084200360?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbnlvbmtlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="图2"><br><br><br><br><h3>四：Windows下提升进程权限</h3><br>&emsp;&emsp;windows的每个用户登录系统后，系统会产生一个访问令牌（access token），其中关联了当前用户的权限信息，用户登录后创建的每一个进程都会有用户access token的拷贝，当进程试图执行某些需要特殊权限的操作或是访问受保护的内核对象，系统会检查其access token的权限信息以决定是否授权操作。Administrator组成员的access token中会含有一些可以执行系统级操作的特权（privilege），如终止任意进程，关闭、重启系统、加载设备驱动和更改系统时间等，不过这些特权默认是被禁用的，当administrator组成员创建的进程中包含一些需要特权的操作时，进程必须首先打开这些禁用的特权以提升自己的权限，否则系统将拒绝进程的操作。注意，非administrator组成员创建的进程无法提升自身的权限，因此下面提到的进程均指administrator组成员创建的进程<br>&emsp;&emsp;Windows以字符串的形式表示系统特权，如”SeCreatePagefilePrivilege”表示该特权用于创建页面文件，“SeDebugPrivilege”表示该特权可用于调试及更改其他进程的内存。为了方便在代码中引用这些字符串，微软在winnt.h中定义了一组宏，如#define SE_DEBUG_NAME TEXT(“SeDebugPrivilege”)。完整的特权列表可以查阅MSDN(<a href="https://msdn.microsoft.com/zh-cn/library/windows/desktop/bb530716%28v=vs.85%29.aspx" target="_blank" rel="noopener">Privilege Constants</a>)一章。虽然Windows使用字符串表示特权，但查询或更改特权的API需要LUID来引用相应的特权，LUID表示local unique identifier，它是一个64位值，在当前系统中是唯一的。为了提升进程权限到指定的特权，我们必须先找到该特权对应的LUID,这时要调用<a href="https://msdn.microsoft.com/zh-cn/library/windows/desktop/aa379180%28v=vs.85%29.aspx" target="_blank" rel="noopener">LookupPrivilegeValue函数</a>。<br><br><h4>LookupPrivilegeValue的原型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI LookupPrivilegeValue(   </span><br><span class="line">  __in_opt      LPCTSTR lpSystemName,   </span><br><span class="line">  __in          LPCTSTR lpName,   </span><br><span class="line">  __out         PLUID lpLuid   </span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>lpSystemName：系统的名字，如果为NULL，就是本地名字（这里就填NULL）</li><li>lpName:特权的名字，<a href="https://msdn.microsoft.com/zh-cn/library/windows/desktop/bb530716%28v=vs.85%29.aspx" target="_blank" rel="noopener">点击查看具体的特权内容</a></li><li>lpLuid：通过指针返回一个LUID类型的Luid的标识，通过这个值就可以填入_LUID_AND_ATTRIBUTES 结构体内。</li></ol><p>&emsp;&emsp;获得特权对应的LUID之后，我们要打开该特权。此时要用到<a href="https://msdn.microsoft.com/zh-cn/library/ff549716%28v=vs.85%29.aspx" target="_blank" rel="noopener">LUID_AND_ATTRIBUTES结构体</a>,其定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _LUID_AND_ATTRIBUTES &#123;</span><br><span class="line">  LUID  Luid;</span><br><span class="line">  ULONG Attributes;</span><br><span class="line">&#125; LUID_AND_ATTRIBUTES, *PLUID_AND_ATTRIBUTES;</span><br></pre></td></tr></table></figure><ol><li>Luid: 是一个标识，不同的Luid代表着各种不同的特权类型</li><li>Attributes: 要这个特权干什么，如启用这个特权（SE_PRIVILEGE_ENABLE）</li><li>Attributes取SE_PRIVILEGE_ENABLED时将打开Luid对应的特权。设置完成后，我们需要调用<a href="https://msdn.microsoft.com/zh-cn/sqlserver/aa375202" target="_blank" rel="noopener">AdjustTokenPrivileges函数</a>，通知操作系统将指定的access token权限中的特权置为打开状态，前面我们说过，进程执行需要特殊权限的操作时系统将检查其access token,因此更改了进程的access token 特权设置，也就是更改了所属进程的特权设置。</li></ol><h4>AdjustTokenPrivileges函数原型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI AdjustTokenPrivileges(</span><br><span class="line">  _In_      HANDLE            TokenHandle,</span><br><span class="line">  _In_      BOOL              DisableAllPrivileges,</span><br><span class="line">  _In_opt_  PTOKEN_PRIVILEGES NewState,</span><br><span class="line">  _In_      DWORD             BufferLength,</span><br><span class="line">  _Out_opt_ PTOKEN_PRIVILEGES PreviousState,</span><br><span class="line">  _Out_opt_ PDWORD            ReturnLength</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>TokenHandle：需要更改特权设置的access token的句柄=OpenProcessToken第三个指针参数传出的句柄值。</li><li>DisableAllPrivileges:表示是否禁用该access token的所有特权</li><li>NewState:用来传递要更新的特权设置，注意它的类型是PTOKEN_PRIVILEGES,PTOKEN_PRIVILEGES</li><li>BufferLength：TOKEN_PRIVILEGES结构体的字节长度</li><li>PreviousState：接收原先的特权的结构体,如果不是NULL,在OpenProcessToken加特权时需要指定TOKEN_PRIVILEGES还必须指定TOKEN_QUERY.如果是NULL,就不用再指定附加的TOKEN_QUERY的特权。</li><li>ReturnLength：TOKEN_PRIVILEGES结构体的字节长度</li><li>返回值：就算这个函数为真，还要调用GetLastError()来检验是否完全成功。如果GetLastError()==ERROR_SUCCESS就代表修改非常成功，这个非常重要，还有就是Vista和Window7里，一定要开管理员模式才能获得成功。</li></ol><p>&emsp;&emsp;<a href="https://msdn.microsoft.com/zh-cn/library/ff556846%28v=vs.85%29.aspx" target="_blank" rel="noopener">TOKEN_PRIVILEGES</a>结构的指针，定义如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _TOKEN_PRIVILEGES &#123;</span><br><span class="line">  ULONG               PrivilegeCount;</span><br><span class="line">  LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];</span><br><span class="line">&#125; TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;</span><br></pre></td></tr></table></figure><ol><li>PrivilegeCount：要修改的特权数据</li><li>Privileges:特权数组</li><li>其中ANYSIZE_ARRAY被定义为1，可以看到TOKEN_PRIVILEGES中包含了用于设置特权信息的LUID_AND_ATTRIBUTES结构，在使用时，只需要进PrivilegeCount赋值为1，然后把Privilege数组的第一个元素（Privileges[0]）的Luid域设置为指定特权的Luid,再将其Attributes域设置为SE_PRIVILEGE_ENABLED，就可以完成TokenHandle表示的access token权限的提升。</li></ol><h3>实例1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;windows.h&gt;      </span><br><span class="line">#include &lt;iostream&gt;      </span><br><span class="line">using namespace std;         </span><br><span class="line">void main()      </span><br><span class="line">&#123;      </span><br><span class="line">        BOOL retn;      </span><br><span class="line">        HANDLE hToken;      </span><br><span class="line">        retn = OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&amp;hToken);      </span><br><span class="line">        if(retn != TRUE)      </span><br><span class="line">        &#123;      </span><br><span class="line">                    cout&lt;&lt;&quot;获取令牌句柄失败!&quot;&lt;&lt;endl;      </span><br><span class="line">                    return;      </span><br><span class="line">        &#125;      </span><br><span class="line">         </span><br><span class="line">        TOKEN_PRIVILEGES tp; //新特权结构体      </span><br><span class="line">        LUID Luid;      </span><br><span class="line">        retn = LookupPrivilegeValue(NULL,SE_DEBUG_NAME,&amp;Luid); </span><br><span class="line">        if(retn != TRUE)      </span><br><span class="line">        &#123;      </span><br><span class="line">                    cout&lt;&lt;&quot;获取Luid失败&quot;&lt;&lt;endl;      </span><br><span class="line">                    return;      </span><br><span class="line">        &#125;      </span><br><span class="line">                //给TP和TP里的LUID结构体赋值      </span><br><span class="line">        tp.PrivilegeCount = 1;      </span><br><span class="line">        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;      </span><br><span class="line">        tp.Privileges[0].Luid = Luid;      </span><br><span class="line">            </span><br><span class="line">        AdjustTokenPrivileges(hToken,FALSE,&amp;tp,sizeof(TOKEN_PRIVILEGES),NULL,NULL);      </span><br><span class="line">        if(GetLastError() != ERROR_SUCCESS)      </span><br><span class="line">        &#123;      </span><br><span class="line">                    cout&lt;&lt;&quot;修改特权不完全或失败!&quot;&lt;&lt;endl;      </span><br><span class="line">        &#125;      </span><br><span class="line">       else    </span><br><span class="line">       &#123;      </span><br><span class="line">                    cout&lt;&lt;&quot;修改成功!&quot;&lt;&lt;endl;      </span><br><span class="line">       &#125;      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4>函数解释</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI OpenProcessToken(   </span><br><span class="line">  __in          HANDLE ProcessHandle,   </span><br><span class="line">  __in          DWORD DesiredAccess,   </span><br><span class="line">  __out         PHANDLE TokenHandle   </span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol><li>ProcessHandle:要修改访问权限的进程句柄（当前进程为GetCurrentProcess()为参数）</li><li>DesiredAccess：指定你要进行的操作类型，如要修改访问令牌的特权，我们要指定第二个参数为TOKEN_ADJUST_PRIVILEGES = &amp;H20（其它一些参数可参考Platform SDK）</li><li>返回的参数，即令牌的句柄==AdjustTokenPrivilege的第一个参数</li></ol><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void mian()</span><br><span class="line">&#123;</span><br><span class="line">HANDLE hToken;      </span><br><span class="line">bool retn = OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&amp;hToken);   </span><br><span class="line">//以一个能修改令牌特权的方式 获取令牌句柄     </span><br><span class="line">if(!retn)    </span><br><span class="line">      return; //获取令牌失败。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3>实例2</h3><br>&emsp;&emsp;下面是一个实际的例子，用来将执行promoteProcessPrivilege的当前进程的指定特权打开，函数参数为指定的特权名，可以传入其宏定义，也可以是完整的字符串表示：<p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BOOL promoteProcessPrivileges(const TCHAR* newPrivileges)</span><br><span class="line">&#123;</span><br><span class="line">HANDLE tokenHandle;</span><br><span class="line">//获得当前进程的access token句柄</span><br><span class="line">if(::OpenProcessToken(::GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;tokenHandle) == FALSE)</span><br><span class="line">return FALSE;</span><br><span class="line">TOKEN_PRIVILEGES structTkp;</span><br><span class="line">//查找newPrivileges参数对应的Luid，并将结果写入structTkp.Privileges[0]的Luid域中</span><br><span class="line">if(::LookupPrivilegeValue(NULL, newPrivileges, &amp;structTkp.Privileges[0].Luid) == FALSE)&#123;</span><br><span class="line">CloseHandle(tokenHandle);</span><br><span class="line">return FASLE;</span><br><span class="line">&#125;</span><br><span class="line">//设置structTkp结构</span><br><span class="line">structTkp.PrivilegeCount = 1;</span><br><span class="line">structTkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">//通知操作系统更改权限</span><br><span class="line">if(::AdjustTokenPrivileges(tokenHandle, FALSE, &amp;structTkp, sizeof(structTkp), NULL, NULL) == FALSE)&#123;</span><br><span class="line">CloseHandle(tokenHandle);</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(tokenHandle);</span><br><span class="line">return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp; 下面使用简单的例子来验证promoteProcessPrivileges函数。下面的traceSystemProcess用于遍历当前系统进程，如果调用traceSystemProcess函数的进程以默认权限运行，对于如csrss.exe之类的进程，函数将没有足够的权限获得其模块名，如果在traceSystemProcess之前调用了promoteProcessPrivileges函数来将进程权限提升至SE_DEBUG_NAME级别,traceSystemProcess函数将能正确打印出如csrss.exe等关键进程的路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">BOOL traceSystemProcess()</span><br><span class="line">&#123;</span><br><span class="line">PROCESSENTRY32 processEntry;</span><br><span class="line">processEntry.dwSize = sizeof(processEntry);</span><br><span class="line"></span><br><span class="line">HANDLE hProcessSnap = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS,0);</span><br><span class="line">if(hProcessSnap == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line">_tprintf(_T(&quot;CreateToolhelp32Snapshot 调用失败!/n&quot;));</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL bMore = ::Process32First(hProcessSnap, &amp;processEntry);</span><br><span class="line">while(bMore)&#123;</span><br><span class="line">_tprintf(_T(&quot;进程名称：%s /n&quot;), processEntry.szExeFile);</span><br><span class="line">_tprintf(_T(&quot;进程ID号：%u /n&quot;), processEntry.th32ProcessID);</span><br><span class="line">HANDLE hProcess = ::OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, </span><br><span class="line">                                                    FALSE, processEntry.th32ProcessID);</span><br><span class="line">if(hProcess != NULL)&#123;</span><br><span class="line">TCHAR szBuffer[MAX_PATH] = &#123;_T(&apos;/0&apos;)&#125;;</span><br><span class="line">if(::GetModuleFileNameEx(hProcess, NULL, szBuffer, MAX_PATH))&#123;</span><br><span class="line">_tprintf(_T(&quot;进程路径：%s /n&quot;), szBuffer);</span><br><span class="line">&#125;</span><br><span class="line">::CloseHandle(hProcess);</span><br><span class="line">&#125;</span><br><span class="line">_tprintf(_T(&quot;/n&quot;));</span><br><span class="line">bMore = ::Process32Next(hProcessSnap,&amp;processEntry);</span><br><span class="line">&#125;</span><br><span class="line">::CloseHandle(hProcessSnap);</span><br><span class="line">return TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;<a href="https://baike.baidu.com/item/PROCESSENTRY32/2828747" target="_blank" rel="noopener">PROCESSENTRY32</a>:用来存放快照进程信息的一个结构体。（存放进程信息和调用成员输出进程信息）用来 <a href="https://baike.baidu.com/item/Process32First/4914822?fr=aladdin" target="_blank" rel="noopener">Process32First</a>指向第一个进程信息，并将进程信息抽取到PROCESSENTRY32中。用<a href="https://baike.baidu.com/item/Process32Next/5509544" target="_blank" rel="noopener">Process32Next</a>指向下一条进程信息</p><p>&emsp;&emsp;综上，Windows用户权限设置和进程权限提升需要用到一组Windows API提升进程权限，需要的函数有：</p><p><ol><br> <li>OpenProcessToken</li><br> <li>LookupPrivilegeValue</li><br> <li>AdjustTokenPrivileges</li><br></ol><br>&emsp;&emsp;使用这组函数提升权限的前提是该进程具备该权限，只是访问令牌中没有启用该权限。如果进程的访问令牌中本身就没有关联该权限，使用AdjustTokenPrivileges函数就会返回ERROR_NOT_ALL_ASSIGNED（值为1300L）的错误码，如何让进程具有该权限？可以通过“控制面板-&gt;管理工具-本地安全策略-本地策略-用户权限指派”设置将该权限关联到指定的用户分组或用户上（Win8某个版本没有本地策略，需要升级），具体设置如下：</p><p><img src="http://img.blog.csdn.net/20171020165815025?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbnlvbmtlbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>&emsp;&emsp;利用AdjustTokenPrivileges提升权限，准确的说不是提升，而是将访问令牌中禁用的权限启用</p><p></p><h3>实例3</h3><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">BOOL SetPrivilege(  </span><br><span class="line">        HANDLE hToken,          // access token handle  </span><br><span class="line">        LPCTSTR lpszPrivilege,  // name of privilege to enable/disable  </span><br><span class="line">        BOOL bEnablePrivilege   // to enable or disable privilege  </span><br><span class="line">        )   </span><br><span class="line">&#123;  </span><br><span class="line">    TOKEN_PRIVILEGES tp;  </span><br><span class="line">    LUID luid;  </span><br><span class="line">  </span><br><span class="line">    if ( !LookupPrivilegeValue(   </span><br><span class="line">        NULL,            // lookup privilege on local system  </span><br><span class="line">        lpszPrivilege,   // privilege to lookup   </span><br><span class="line">        &amp;luid ) )        // receives LUID of privilege  </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;LookupPrivilegeValue error: %u\n&quot;, GetLastError() );   </span><br><span class="line">        return FALSE;   </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    tp.PrivilegeCount = 1;  </span><br><span class="line">    tp.Privileges[0].Luid = luid;  </span><br><span class="line">    if (bEnablePrivilege)  </span><br><span class="line">        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;  </span><br><span class="line">    else  </span><br><span class="line">        tp.Privileges[0].Attributes = 0;  </span><br><span class="line">  </span><br><span class="line">    // Enable the privilege or disable all privileges.  </span><br><span class="line">  </span><br><span class="line">    if ( !AdjustTokenPrivileges(  </span><br><span class="line">        hToken,   </span><br><span class="line">        FALSE,   </span><br><span class="line">        &amp;tp,   </span><br><span class="line">        sizeof(TOKEN_PRIVILEGES),   </span><br><span class="line">        (PTOKEN_PRIVILEGES) NULL,   </span><br><span class="line">        (PDWORD) NULL) )  </span><br><span class="line">    &#123;   </span><br><span class="line">        printf(&quot;AdjustTokenPrivileges error: %u\n&quot;, GetLastError() );   </span><br><span class="line">        return FALSE;   </span><br><span class="line">    &#125;   </span><br><span class="line">  </span><br><span class="line">    if (GetLastError() == ERROR_NOT_ALL_ASSIGNED)  </span><br><span class="line">  </span><br><span class="line">    &#123;  </span><br><span class="line">        printf(&quot;The token does not have the specified privilege. \n&quot;);  </span><br><span class="line">        return FALSE;  </span><br><span class="line">    &#125;   </span><br><span class="line">  </span><br><span class="line">    return TRUE;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">void main( )  </span><br><span class="line">&#123;  </span><br><span class="line">    HANDLE hToken;  </span><br><span class="line">    BOOL bRet = OpenProcessToken(GetCurrentProcess(),TOKEN_ALL_ACCESS,&amp;hToken);  </span><br><span class="line">    SetPrivilege(hToken,SE_DEBUG_NAME,TRUE);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>&emsp;&emsp;这段代码在xp上没有问题，但如果在Window7或者vista上，如果程序以标准用户启动，AdjustTokenPrivileges将会调用失败，以管理员身份启动没有问题<br>&emsp;&emsp;这是因为在Window7上，标准用户权限很少，没有Debug权限，更无从谈起启用Debug权限，用户可以以管理员和标准用户两种方式启用控制台，输入命令whoami/All来查看两种权限下权限的不同。<br>&emsp;&emsp;即使提升调试权限，也不意味着对其他进程调用OpenProcess会成功（例如win7系统下的system和audiodg进程）</p><blockquote><p><a href="http://blog.csdn.net/zacklin/article/details/7663129" target="_blank" rel="noopener">http://blog.csdn.net/zacklin/article/details/7663129</a></p><p><a href="http://blog.csdn.net/yockie/article/details/17029293" target="_blank" rel="noopener">http://blog.csdn.net/yockie/article/details/17029293</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3&gt;一、概述&lt;/h3&gt;&lt;br&gt;&amp;emsp;&amp;emsp;Windows系统具有很完善的安全和认证机制，称做访问控制机制。程序的执行主体（线程）在访问对象（文件，事件）时，系统会根据线程的“权限”和线程需要访问的对象所具有的“安全描述符”中的访问控制列表是否匹配来进行认证，决定一个线程是否可以操作一个对象。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://wusz.com/2018/04/27/hello-world/"/>
    <id>http://wusz.com/2018/04/27/hello-world/</id>
    <published>2018-04-27T03:21:39.518Z</published>
    <updated>2018-04-27T03:21:39.518Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
